// Generated by CoffeeScript 1.10.0
(function() {
  var Model, ModelFactory, cache, config, database, db, model, should;

  should = require('should');

  config = require('../conf/config');

  database = require('../../lib/database');

  cache = require('../../lib/cache').init();

  db = database.getPool(config.database);

  ModelFactory = require('../../lib/model').init({
    db: db,
    cache: cache
  });

  require('../../lib/criteria').init({
    db: db,
    cache: cache
  });

  Model = ModelFactory({
    tableName: 'common_test',
    fields: [
      {
        name: 'non_uniq'
      }, {
        unique: true,
        name: 'uniq'
      }, {
        pk: true,
        name: 'id'
      }
    ],
    indices: []
  });

  model = new Model({
    'non_uniq': 1,
    'uniq': 2,
    'id': 3
  });

  describe('lib/common', function() {
    before(function() {
      return db.query('create table `common_test` (`id` int NOT NULL, `uniq` int, `non_uniq` int, PRIMARY KEY (`id`))', [], (function() {}));
    });
    describe('classMethods', function() {
      describe('._walk', function() {
        return it('should return an array contains the method with specified prefix', function() {
          var ret;
          Model.prototype.validateFoo = function(callback) {
            return callback(null);
          };
          Model.prototype.validateBar = function(callback) {
            return callback(null);
          };
          ret = Model._walk(model, 'validate');
          return ret.length.should.equal(2);
        });
      });
      describe('.insert', function() {
        it('should got an error when invoking with a non-model object', function(done) {
          return Model.insert({}, function(err) {
            should.exists(err);
            return done();
          });
        });
        return context('when invoking with a model', function() {
          it('should be succeed', function(done) {
            return Model.insert(model, function(err, result) {
              should.exists(result);
              return done();
            });
          });
          it('should be fault when a validator test failed', function(done) {
            Model.prototype.validateErr = function(callback) {
              return callback(new Error);
            };
            return Model.insert(model, function(err) {
              should.exists(err);
              return done();
            });
          });
          return after(function() {
            return delete Model.prototype.validateErr;
          });
        });
      });
      describe('.update', function() {
        it('should got an error when invoking with a non-model object', function() {
          return Model.update({}, function(err) {
            return should.exists(err);
          });
        });
        return context('when invoking with a model', function() {
          it('should be succeed', function(done) {
            return Model.update(model, function(err, result) {
              should.exists(result);
              return done();
            });
          });
          it('should be fault when a validator test failed', function(done) {
            Model.prototype.validateErr = function(callback) {
              return callback(new Error);
            };
            return Model.update(model, function(err) {
              should.exists(err);
              return done();
            });
          });
          return after(function() {
            return delete Model.prototype.validateErr;
          });
        });
      });
      describe('.all', function() {
        return it('should return the matched items', function(done) {
          return Model.all(function(err, ret) {
            should.not.exists(err);
            ret[0].attributes.non_uniq.should.equal(1);
            return done();
          }, {
            non_uniq: 1
          });
        });
      });
      describe('.count', function() {
        it('should return the count of the matched items', function(done) {
          return Model.count({
            uniq: {
              op: 'gt',
              value: 1
            }
          }, function(err, count) {
            should.not.exists(err);
            count.should.equal(1);
            return done();
          });
        });
        return it('should be ok when opts contains nothing', function(done) {
          return Model.count({}, function(err, count) {
            should.not.exists(err);
            count.should.equal(1);
            return done();
          });
        });
      });
      describe('.find', function() {
        return it('should be ok and return the matched result', function(done) {
          return Model.find({
            uniq: 2
          }, function(err, result) {
            should.not.exists(err);
            result[0].attributes.uniq.should.equal(2);
            return done();
          });
        });
      });
      describe('.findOne', function() {
        return it('should be ok and return the certain one item that matches the conditions', function(done) {
          return Model.findOne({
            uniq: 2,
            non_uniq: 1
          }, function(err, result) {
            should.not.exists(err);
            result.attributes.uniq.should.equal(2);
            result.attributes.non_uniq.should.equal(1);
            return done();
          });
        });
      });
      describe('.findWithCount', function() {
        return it('should return the matched results with its count', function(done) {
          return Model.findWithCount({
            uniq: 2
          }, function(err, ret) {
            should.not.exists(err);
            ret.should.have.properties(['rows', 'total']);
            return done();
          });
        });
      });
      describe('.findByIndex', function() {
        return it('should be ok and return the item with the given index', function(done) {
          return Model.findByIndex('id', 3, function(err, ret) {
            should.not.exists(err);
            ret[0].attributes.non_uniq.should.equal(1);
            return done();
          });
        });
      });
      describe('.findByUniqueKey', function() {
        return it('should be ok and return the item with the given unique key', function(done) {
          return Model.findByUniqueKey('uniq', 2, function(err, result) {
            should.not.exists(err);
            result.attributes.uniq.should.equal(2);
            return done();
          });
        });
      });
      describe('.findById', function() {
        return it('should be ok and return the item with the given id', function(done) {
          return Model.findById(3, function(err, ret) {
            should.not.exists(err);
            ret.attributes.uniq.should.equal(2);
            return done();
          });
        });
      });
      describe('.findByIds', function() {
        return it('should be ok and return a group of items with the given ids', function(done) {
          return Model.findByIds([1, 2, 3, 4], function(err, ret) {
            var i;
            should.not.exists(err);
            ((function() {
              var j, len, results;
              results = [];
              for (j = 0, len = ret.length; j < len; j++) {
                i = ret[j];
                if (i != null) {
                  results.push(i);
                }
              }
              return results;
            })()).length.should.equal(1);
            return done();
          });
        });
      });
      describe('.delete', function() {
        it('should got an error when invoking with a non-model object', function() {
          return Model["delete"]({}, function(err) {
            return should.exists(err);
          });
        });
        return context('when invoking with a model', function() {
          return it('should be succeed', function(done) {
            return Model["delete"](model, function(err, result) {
              should.exists(result);
              return done();
            });
          });
        });
      });
      describe('.before', function() {
        it('should do nothing when add hooks on a non-supprot method', function() {
          Model.before('find', (function() {}));
          return Model._beforeHooks.find.length.should.equal(0);
        });
        return it('should be succeed when add a valid hook', function() {
          Model.before('insert', function(done) {
            return done(null);
          });
          return should.exists(Model._beforeHooks.insert);
        });
      });
      describe('.after', function() {
        it('should do nothing when add hooks on a non-supprot method', function() {
          Model.after('find', (function() {}));
          return Model._afterHooks.find.length.should.equal(0);
        });
        return it('should be succeed when add a valid hook', function() {
          Model.after('insert', function(done) {
            return done(null);
          });
          return should.exists(Model._afterHooks.insert);
        });
      });
      return describe('._isValidMethod', function() {
        return it('should only success when method name matchs insert or update or delete', function() {
          should.ok(Model._isValidMethod('insert'));
          should.ok(Model._isValidMethod('update'));
          should.ok(Model._isValidMethod('delete'));
          return Model._isValidMethod('find').should.be["false"]();
        });
      });
    });
    return describe('instanceMethods', function() {
      describe('.insert', function() {
        return it('should be ok', function(done) {
          return model.insert(function(err, result) {
            should.not.exists(err);
            return done();
          });
        });
      });
      describe('.update', function() {
        return it('should be ok', function(done) {
          return model.update(function(err, result) {
            should.not.exists(err);
            return done();
          });
        });
      });
      return describe('.delete', function() {
        return it('should be ok', function(done) {
          return model["delete"](function(err, result) {
            should.not.exists(err);
            return done();
          });
        });
      });
    });
  });

}).call(this);
